/*
형 변환
함수와 연산자에 전달되는 값은 대부분 적절한 자료형으로 자동 변환됨.
이 외에, 전달받은 값을 의도적으로 원하는 타입으로 변환해주는 경우도 형 변환이다.

1. 문자형 형변환
alert메서드는 매개변수로 문자형을 받음. 그렇기 때문에 다른 형의 값을 받으면 문자형으로 자동 변환됨.
이외 String(value)함수를 호출해 전달받은 값을 문자열로 변환할 수도 있음
문자열과 문자열이 아닌 값을 '+'할 경우, 문자열이 아닌 값을 문자열로 형변환하여 문자열 간의 합으로 반환한다. (★)

2. 숫자형 형변환
숫자형은 수학과 관련된 함수와 표현식에서 자동으로 형변환이 일어난다.
숫자형과 숫자형이 아닌 값을 -,*,/할 경우, 숫자형으로 형변환하여 반환한다. 만약 숫자형으로 변환되지 않을 경우 NaN의 결과를 반환한다. (★★★)

3. boolean 형변환
논리연산을 수행할 때 발생.

결국 형변환에 있어서 다음을 기억해주는 것이 좋음.
문자열과 문자열이 아닌 값을 '+'할 경우, 문자열이 아닌 값을 문자열로 형변환하여 문자열 간의 합으로 반환한다. (★)
숫자형과 숫자형이 아닌 값을 -,*,/할 경우, 숫자형으로 형변환하여 반환한다. 만약 숫자형으로 변환되지 않을 경우 NaN의 결과를 반환한다. (★★★)
*/
let value = true;   // boolean
value = String(value);  // String으로 형변환
console.log(typeof value);

console.log ("6" / "2");    // 숫자형으로 변환하여 3이라는 결과를 반환
let str = "123";
console.log(typeof str);    // String
let num = Number(str);
console.log(typeof num);    // Number

console.log(Boolean(1));    // true. 숫자1은 true를 의미
console.log(Boolean(0));    // false. 숫자0은 false를 의미
console.log(Boolean("hello"));  // 값이 존재하므로 true
console.log(Boolean("0"));  // 0은 false이나 문자열 0은 값이 존재하므로 true
console.log(Boolean(""));   // 값이 비어있으므로(null) false

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* 
기본연산자
1. 단항, 이항, 피연산자
피연산자(=인수): 연산자가 아닌 것들. 즉, 연산자가 아닌 숫자들을 의미
단항: 하나의 피연산자를 받는 연산자
이항: 두 개의 피연산자를 받는 연산자

2. 나머지연산자, 거듭제곱연산자
나머지 연산자: %
거듭제곱 연산자: **

3. 연산자(+)와 형변환
JS에서 '+'연산자는 두 개의 피연산자 중 하나라도 문자열이면 문자열 연결 연산자로 동작

4. 쉼표연산자
쉼표연산자는 여러 표현식을 코드 한 줄에서 평가할 수 있게 해준다.
이 때 표현식 각각이 모두 평가되지만, '마지막 표현식의 평가 결과만 반환'된다는 점에 유의
*/
let x = 1;
let y = 3;
x = -x;
console.log(x);     // 단항 연산자
console.log(y - x); // 이항 연산자

console.log(5 % 2); // 1. 나머지 연산자
console.log(2 ** 3) // 8. 거듭제곱 연산자

console.log("Ez" + "Real"); // EzReal. 문자열 연결 연산자로 동작
console.log('1' + 2);       // "12". 하나라도 문자열이면 연결 연산자로 동작
console.log(2 + 2 + '1');   // "41"
console.log("EzReal" * 2);  // NaN. 문자열을 곱하면 오류가 발생
console.log("EzReal" / 2);  // NaN. 문자열을 숫자로 나누면 오류가 발생
console.log( +"2" + +"3");  // 5. 숫자형이 아닌 값들에 +를 붙여줄 경우 숫자형으로 변환해줌.

let a = (1 + 2, 3 + 4); // 쉼표연산자
console.log(a);     // 7. 마지막 표현식의 평가 결과만 반환된다.
for (a = 1, b = 3, c = a*b; a < 10; a++) { 
    // 마지막 결과만 반환한다는 점을 고려하였을 때, 다음과 같이 활용할 수도 있음.
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
기본연산자와 형변환 간단 문제
*/

console.log("" + 1 + 0);    // 10. 문자열이 포함되어 있으므로 문자열이 아닌 값들이 전부 문자열로 변환되어 합해짐.
console.log("" - 1 + 0);    // -1. '-'는 숫자형만을 인수로 받음. 그러므로 빈 문자열 ""은 숫자 0으로 변환되기 때문에 -1이 된다. (★)
console.log(true + false);  // 1. 1+0이므로 1이라는 결과가 반환됨.

console.log(6 / "3");       // 2. -, *, /는 숫자형 형변환이 이루어지기 때문에 2라는 결과를 반환한다. (★★★)
console.log("2" * "3");     // 6. -, *, /는 숫자형 형변환이 이루어지기 때문에 2라는 결과를 반환한다. (★★★)

console.log(4 + 5 + "px");  // 9px.
console.log("$" + 4 + 5);   // $45. 위 문제를 고려하였을 때, 문자열이 언제오냐를 고려해야된다.

console.log("4px" - 2);     // NaN. 숫자형 형변환이 이루어질 때 숫자형이 나오지 않기 때문에 NaN이라는 결과가 반환된다. (★★★)

console.log(7 / 0);         // Infinity.

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
비교연산자

문자열 비교
JS는 '사전'순으로 문자열을 비교. 즉, JS는 문자열을 구성하는 문자 하나하나를 비교해가며 문자열을 비교한다.
정확히는 '사전'이 아니라 '유니코드' 순이다. 그렇기 때문에 소문자가 대문자보다 더 크다.
문자열 길이가 다르면 길이가 긴 문자열이 더 크다고 간주한다.

다른 형을 가진 값 간의 비교
==  : 느슨한 동등 비교. 두 값의 자료형이 다를 때 JS가 자동으로 형 변환(주로 숫자형으로)을 수행한 후 비교한다.
=== : 엄격한 동등 비교. 두 값과 자료형이 모두 같아야 true를 반환
*/
console.log('Z' > 'A'); // true
console.log('Glow' > 'Glee');   // true
console.log('Bee' > 'Be');  // true. 문자열 길이가 다르면 길이가 긴 문자열이 더 크다고 간주.

console.log('2' > 1);   // true. 문자열 '2'를 숫자형 2로 변환.
console.log('01' == 1); // true. 문자열 '01'을 숫자형 1로 변환.
console.log(true == 1); // true. boolean의 경우 true는 1, false는 0으로 변환한 후 비교한다.

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/* 
논리연산자
1. ||: OR
OR 연산자의 경우 || 연산을 여러 개 체이닝하면 첫 번째 truthy를 찾는다. 
result = value1 || value2 || value3;

2. &&: AND
AND 연산자의 경우 && 연산을 여러 개 체이닝하면 첫 번째 falsy를 찾는다.

3. !: NOT
*/
let hour = 9;
if (hour < 10 || hour > 18) {           // hour가 10보다 작거나 18보다 클 경우
    console.log('영업시간이 아닙니다.');
}

let firstname = ""; let lastname = ""; let nickname = "바이올렛";
console.log(firstname || lastname || nickname || "다 틀림");    // 바이올렛.

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*
nullish 병합연산자
??: 값이 확정되어 있는 변수를 찾을 때 사용
let nullish_2 = a ?? b; -> a가 null이 아니고 undefined도 아니면 a, 그 외의 경우는 b
*/
let z_1; let z_2;
let nullish = (z_1 !== null && z_2 !== undefined) ? z_1 : z_2;
let nullish_2 = z_1 ?? z_2; // nullish 변수와 같음. 만약 z_1이 null이 아니고 undefined도 아니면 z_1, 그 외의 경우는 z_2 

console.log(nullish_2);